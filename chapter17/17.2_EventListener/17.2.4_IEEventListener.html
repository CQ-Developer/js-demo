<html>

<head></head>

<body>
    <input id="myBtn1" type="button" value="Click Me 1">
    <input id="myBtn2" type="button" value="Click Me 2">
    <input id="myBtn3" type="button" value="Click Me 3">
    <input id="myBtn4" type="button" value="Click Me 4">
    
    <!-- 17.2.4 IE事件处理程序
    
        IE实现了与DOM类似的方法: attachEvent(), detachEvent()
        这两个方法接收两个同样的参数: 事件处理程序的名字, 事件处理函数
        因为IE8及更早版本只支持事件冒泡, 所以使用attachEvent()添加的事件处理程序会添加到冒泡阶段

        在IE中使用attachEvent()与使用DOM0方式的主要区别是事件处理程序的作用域
        使用DOM0方式时, 事件处理程序中的this值等于目标元素
        而使用attachEvent()时, 事件处理程序是在全局作用域中运行的, 因此this等于window

        与addEventListener()一样, 使用attachEvent()方法也可以给一个元素添加多个事件处理程序
        不过, 与DOM方法不同的是, 这里的事件处理程序会以添加它们的顺序反向触发

        可以使用detachEvent()移除通过attachEvent()添加的事件处理程序
        与使用DOM方法类似, 使用匿名函数的事件处理程序无法移除
        需要给detachEvent()传递和attachEvent()相同的函数引用
    -->
    <script>
        // 使用attachEvent()给按钮添加click事件处理程序
        var btn1 = document.getElementById("myBtn1");
        btn1.attachEvent("onclick", function () {
            console.log("Clicked");
        });

        // 验证attachEvent()中的this对象
        var btn2 = document.getElementById("myBtn2");
        btn2.attachEvent("onclick", function () {
            console.log(this === window);
        });

        // 使用attachEvent()添加多个事件处理程序
        var btn3 = document.getElementById("myBtn3");
        btn3.attachEvent("onclick", function () {
            console.log("Click");
        });
        btn3.attachEvent("onclick", function () {
            console.log("Hello World");
        });

        // 使用detachEvent()移除事件处理程序
        var btn4 = document.getElementById("myBtn4");
        var handler4 = function () {
            console.log("Clicked");
        };
        btn4.attachEvent("onclick", handler4);
        btn4.detachEvent("onclick", handler4);
    </script>
</body>

</html>