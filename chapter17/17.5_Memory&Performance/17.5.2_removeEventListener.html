<html>

<head></head>

<!-- 17.5.2 删除事件处理程序
    
    把事件处理程序指定给元素后, 在浏览器代码和负责页面交互的JS代码之间就建立了联系
    这种联系建立的越多, 页面性能就越差
    除了通过事件委托来限制这种联系之外, 还应该及时删除不用的事件处理程序

    导致这个问题的原因主要有两个
    第一个是删除带有事件处理程序的元素
    比如通过真正的DOM方法removeChild()或replaceChild()删除节点
    最常见的还是使用innerHTML整体替换页面的某一部分
    这时候, 被innerHTML删除的元素上如果有事件处理程序, 就不会被垃圾收集程序正常清理

    在IE8及更早版本, 这时候就会有问题了
    很有可能元素的引用和事件处理程序的引用都会残留在内存中
    如果知道某个元素会被删除, 那么最好在删除它之前手工删除它的事件处理程序

    但也要注意, 在事件处理程序中删除按钮会阻止事件冒泡
    只有事件目标仍然存在与文档中时, 事件才会冒泡

    另一个可能导致内存中残留引用的问题是页面卸载
    同样, IE8及更早版本在这种情况下有很多问题, 不过好像所有浏览器都会受这个问题影响
    如果页面卸载后事件处理程序没有被清理, 则它们仍然会残留在内存中
    之后, 浏览器每次加载和卸载页面, 内存中残留对象的数量都会增加, 这是因为事件处理程序不会被回收

    一般来说, 最好在unload事件处理程序中趁页面尚未卸载先删除所有事件处理程序
    这时候也能体现使用事件委托的优势, 因为事件处理程序很少, 所有很容易记住要删除哪些
    关于卸载页面时的清理, 可以记住一点: load事件处理程序中做了什么, 最好在unload事件处理程序中恢复

    注意, 在页面中使用unload事件处理程序意味着页面不会被保存在往返缓存中
-->
<body>
    <div id="myDiv">
        <input type="button" value="Click Me" id="myBtn" />
    </div>
    <script type="text/javascript">
        let btn = document.getElementById("myBtn");
        btn.onclick = function () {
            console.log("Clicked");
            // 手工删除事件处理程序
            btn.onclick = null;
            document.getElementById("myDiv").innerHTML = "Processing...";
        };
    </script>
</body>

</html>