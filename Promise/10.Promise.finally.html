<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
</head>

<body>
    <!--
        https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise/finally
    -->
    <script>
        // onFinally handler will pass backwards the state from upstream
        let fp1 = Promise.resolve("some values")
            .finally(() => console.log("finally do something"));
        setTimeout(console.log, 1000, "fp1:", fp1);

        // so it is with rejected Promise
        let fp2 = Promise.reject("some reason")
            .finally(() => console.log("finally do something"));
        setTimeout(console.log, 1000, "fp2:", fp2);

        // if the onFinally handler throws an error
        // the returned Promise will be rejected
        let fp3 = Promise.resolve("some values")
            .finally(() => {
                throw "some error occurred in the finally method";
            });
        setTimeout(console.log, 1000, "fp3", fp3);

        // and returned a rejected Promise in onFinally handler
        // will also made the new Promise returned by onFinally handler into rejected state
        let fp4 = Promise.resolve("some values")
            .finally(() => Promise.reject("some reason in the finally method"));
        setTimeout(console.log, 1000, "fp4", fp4);

        // finally method with onFinally handler is good at cleaning up work
        let set = new Set([1, 2, 3]);
        let fp5 = Promise.resolve()
            .finally(() => set.clear());
        console.log(set);
        setTimeout(console.log, 1000, "set:", set);
    </script>
</body>

</html>